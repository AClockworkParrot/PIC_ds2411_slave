CCS PCB C Compiler, Version 4.068, 35766               07-мар-25 18:56

               Filename: main.lst

               ROM used: 187 words (73%)
                         Largest free fragment is 69
               RAM used: 5 (31%) at main() level
                         8 (50%) worst case
               Stack:    1 locations

*
0000:  MOVWF  05
0001:  GOTO   056
0002:  GOTO   00F
0003:  GOTO   006
0004:  GOTO   029
0005:  GOTO   045
.................... #include "C:\PIC_projects\ds2411_v2\main.h" 
.................... #include <10F220.h> 
.................... //////// Standard Header file for the PIC10F220 device //////////////// 
.................... #device PIC10F220 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOMCPU                   //Master Clear Pull-up disabled 
.................... #FUSES IOSC8                    //INTOSC speed 8MHz 
....................  
.................... #use delay(clock=8000000) 
*
0045:  MOVF   14,W
0046:  BTFSC  03.2
0047:  GOTO   055
0048:  MOVLW  02
0049:  MOVWF  11
004A:  CLRF   10
004B:  DECFSZ 10,F
004C:  GOTO   04B
004D:  DECFSZ 11,F
004E:  GOTO   04A
004F:  MOVLW  97
0050:  MOVWF  10
0051:  DECFSZ 10,F
0052:  GOTO   051
0053:  DECFSZ 14,F
0054:  GOTO   048
0055:  GOTO   0BF (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B0,bits=8) 
....................  
....................  
.................... #include "config.h" 
.................... /* 
....................  *    config.h 
....................  * 
....................  *    created: April 2011 
....................  *    author: Bartek Fabiszewski (www.fabiszewski.net) 
....................  */ 
....................  
.................... #ifndef CONFIG_H_ 
.................... #define CONFIG_H_ 
....................  
.................... #define drive_OW_low() { SET_TRIS_B(0b11111110); OUTPUT_LOW(PIN_B0); } 
.................... #define drive_OW_high() { SET_TRIS_B(0b11111111);} 
.................... #define OW_presence_pulse() {\ 
.................... drive_OW_low();  \ 
.................... delay_us(120); \ 
.................... drive_OW_high(); \ 
.................... } 
....................  
.................... #define _XTAL_FREQ    8000000 // 4MHz 
....................  
.................... // leave uncommented only necessary module 
.................... // only one module may be compiled into hex due to PIC code space limits 
.................... #define SHT1x     // leave uncommented if you have sht2x sensor supporting i2c connected to pic 
....................  
.................... //#define TRUE                1 
.................... //#define FALSE               0 
.................... #define INPUT               1 
.................... #define OUTPUT              0 
.................... #define HIGH                1 
.................... #define LOW                 0 
....................  
.................... #define OW                  PIN_B0          //pin 6 for 1-wire data (this can't be changed) 
.................... #define TRIS_OW             TRISB0 
....................  
.................... #define MOD1                             //my first design used different pins 
....................  
.................... #ifdef MOD1 
.................... #define DATA                RB6          //pin 12 for sht data 
.................... #define SCK                 RB7          //pin 13 for sht clock 
.................... #define TRIS_DATA           TRISB6 
.................... #define TRIS_SCK            TRISB7 
....................  
.................... // some global vars 
.................... //byte ow_error;      // error on ow line 
.................... ///byte sensor_error;  // error on sensor line 
.................... ///byte scratchpad[6]; // 6-byte buffer [h-msb h-lsb h-crc t-msb t-lsb t-crc] 
....................  
....................  
....................  
.................... //#include "sht1x.h" 
....................  
....................  
.................... #endif /* CONFIG_H_ */ 
....................  
....................  
.................... byte const m[8] = {0x01, 0xE0, 0x65, 0x72 0x11, 0x00, 0x00, 0xA3};  // serial number sequence 
....................  
....................  
.................... // func for detect reset pulse 
.................... byte OW_reset_pulse (void) 
.................... { 
....................     byte del_count = 50; 
*
000F:  MOVLW  32
0010:  MOVWF  14
....................     while (del_count--) // this loop takes 13.6 us 
....................     { 
0011:  MOVF   14,W
0012:  DECF   14,F
0013:  XORLW  00
0014:  BTFSC  03.2
0015:  GOTO   01D
....................         delay_us(10); 
0016:  MOVLW  06
0017:  MOVWF  10
0018:  DECFSZ 10,F
0019:  GOTO   018
001A:  NOP
....................         if (OW)         // 124.8 us to here since master pulls bus low 
....................         { 
....................             break; 
001B:  GOTO   01D
....................         } 
....................     } 
001C:  GOTO   011
....................     if (del_count > 40) { 
001D:  MOVLW  28
001E:  MOVWF  10
001F:  MOVF   14,W
0020:  SUBWF  10,W
0021:  BTFSC  03.0
0022:  GOTO   026
....................         return 0; // too short 
0023:  MOVLW  00
0024:  MOVWF  11
0025:  GOTO   028
....................     } 
....................     return 1;     // reset pulse detected 
0026:  MOVLW  01
0027:  MOVWF  11
.................... } 
0028:  GOTO   067 (RETURN)
....................  
.................... // 1-wire slave write bit 
.................... // must be run immediately after line is pulled down by master 
.................... void OW_write_bit (byte write_bit) 
.................... { 
....................     if (write_bit) 
0029:  MOVF   17,F
002A:  BTFSC  03.2
002B:  GOTO   032
....................     { 
....................         //writing a bit '1' 
....................         delay_us(55);//55                // bus is already pulled high by pullup resistor, so just wait 
002C:  MOVLW  24
002D:  MOVWF  10
002E:  DECFSZ 10,F
002F:  GOTO   02E
0030:  NOP
....................     } 
....................     else 
0031:  GOTO   044
....................     { 
....................         //writing a bit '0' 
....................         drive_OW_low();                    // drive the bus low 
0032:  MOVLW  FE
0033:  TRIS   6
0034:  MOVWF  12
0035:  BCF    12.0
0036:  MOVF   12,W
0037:  TRIS   6
0038:  BCF    06.0
....................         delay_us(17);//15 
0039:  MOVLW  0B
003A:  MOVWF  10
003B:  DECFSZ 10,F
003C:  GOTO   03B
....................         drive_OW_high();                   // release the bus 
003D:  MOVLW  FF
003E:  TRIS   6
003F:  MOVWF  12
....................         delay_us(35);//35 
0040:  MOVLW  17
0041:  MOVWF  10
0042:  DECFSZ 10,F
0043:  GOTO   042
....................     } 
.................... } 
0044:  RETLW  00
....................  
.................... // func for write bytes 
.................... void OW_write_byte (byte write_data) 
.................... { 
....................     OW_write_bit(write_data & 0x01);     // sending LS-bit first 
*
007C:  MOVF   15,W
007D:  ANDLW  01
007E:  MOVWF  16
007F:  MOVWF  17
0080:  CALL   029
....................     while (OW);                          // wait for master set bus low 
0081:  GOTO   081
....................     write_data >>= 1;                    // shift the data byte for the next bit to send 
0082:  BCF    03.0
0083:  RRF    15,F
....................     OW_write_bit(write_data & 0x01); 
0084:  MOVF   15,W
0085:  ANDLW  01
0086:  MOVWF  16
0087:  MOVWF  17
0088:  CALL   029
....................     while (OW); 
0089:  GOTO   089
....................     write_data >>= 1; 
008A:  BCF    03.0
008B:  RRF    15,F
....................     OW_write_bit(write_data & 0x01); 
008C:  MOVF   15,W
008D:  ANDLW  01
008E:  MOVWF  16
008F:  MOVWF  17
0090:  CALL   029
....................     while (OW); 
0091:  GOTO   091
....................     write_data >>= 1; 
0092:  BCF    03.0
0093:  RRF    15,F
....................     OW_write_bit(write_data & 0x01); 
0094:  MOVF   15,W
0095:  ANDLW  01
0096:  MOVWF  16
0097:  MOVWF  17
0098:  CALL   029
....................     while (OW); 
0099:  GOTO   099
....................     write_data >>= 1; 
009A:  BCF    03.0
009B:  RRF    15,F
....................     OW_write_bit(write_data & 0x01); 
009C:  MOVF   15,W
009D:  ANDLW  01
009E:  MOVWF  16
009F:  MOVWF  17
00A0:  CALL   029
....................     while (OW); 
00A1:  GOTO   0A1
....................     write_data >>= 1; 
00A2:  BCF    03.0
00A3:  RRF    15,F
....................     OW_write_bit(write_data & 0x01); 
00A4:  MOVF   15,W
00A5:  ANDLW  01
00A6:  MOVWF  16
00A7:  MOVWF  17
00A8:  CALL   029
....................     while (OW); 
00A9:  GOTO   0A9
....................     write_data >>= 1; 
00AA:  BCF    03.0
00AB:  RRF    15,F
....................     OW_write_bit(write_data & 0x01); 
00AC:  MOVF   15,W
00AD:  ANDLW  01
00AE:  MOVWF  16
00AF:  MOVWF  17
00B0:  CALL   029
....................     while (OW); 
00B1:  GOTO   0B1
....................     write_data >>= 1; 
00B2:  BCF    03.0
00B3:  RRF    15,F
....................     OW_write_bit(write_data & 0x01); 
00B4:  MOVF   15,W
00B5:  ANDLW  01
00B6:  MOVWF  16
00B7:  MOVWF  17
00B8:  CALL   029
.................... } 
....................  
.................... void main() 
.................... { 
*
0056:  CLRF   04
0057:  BCF    12.0
0058:  MOVF   12,W
0059:  TRIS   6
005A:  BSF    06.0
.................... byte i; 
....................     // Initialization 
....................     //  setup_timer_0(RTCC_INTERNAL | RTCC_DIV_1); // Configure Timer 0 
....................     //   SET_TRIS_B(0xFF); // Configure port B as input 
....................     SETUP_WDT(WDT_2304MS); // Configure Watchdog Timer 
*
005D:  MOVLW  0F
005E:  MOVWF  10
005F:  MOVLW  07
0060:  CLRF   01
0061:  MOVLW  0F
0062:  OPTION
0063:  CLRWDT
0064:  MOVF   10,W
0065:  OPTION
....................  
....................     while (TRUE) { 
....................         // Periodic code execution, similar to interrupts 
....................         
....................          
....................         // Check for reset and reset 1-Wire device 
....................         if (OW_reset_pulse()) {  // if reset pulse detected 
0066:  GOTO   002
0067:  MOVF   11,F
0068:  BTFSC  03.2
0069:  GOTO   0BB
....................             delay_us(30); // эмпирически подобрать задержку 
006A:  MOVLW  13
006B:  MOVWF  10
006C:  DECFSZ 10,F
006D:  GOTO   06C
006E:  GOTO   06F
....................         for ( i = 0; i < 8; i++) {  // Loop over the array length 
006F:  CLRF   13
0070:  MOVLW  07
0071:  MOVWF  10
0072:  MOVF   13,W
0073:  SUBWF  10,W
0074:  BTFSS  03.0
0075:  GOTO   0BB
....................     
....................         while (OW); // Wait for 1-Wire to be idle 
0076:  GOTO   076
....................     
....................         OW_write_byte(m[i]); // Send the byte 
0077:  MOVF   13,W
0078:  CALL   006
0079:  MOVWF  14
007A:  MOVF   14,W
007B:  MOVWF  15
....................         } 
*
00B9:  INCF   13,F
00BA:  GOTO   070
....................    } 
....................          
....................      //   Watchdog Timer handling 
....................      RESTART_WDT(); 
00BB:  CLRWDT
....................         delay_ms(100); // Delay 0.1 s * 10 = 1 s 
00BC:  MOVLW  64
00BD:  MOVWF  14
00BE:  GOTO   005
....................     }} 
00BF:  GOTO   066
....................  
00C0:  SLEEP

Configuration Fuses:
   Word  1: 0FEB   NOMCLR NOPROTECT NOWDT NOMCPU IOSC8
